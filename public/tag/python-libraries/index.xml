<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python Libraries | Stanley Z. Hua</title>
    <link>/tag/python-libraries/</link>
      <atom:link href="/tag/python-libraries/index.xml" rel="self" type="application/rss+xml" />
    <description>Python Libraries</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sat, 11 Jul 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/img/me</url>
      <title>Python Libraries</title>
      <link>/tag/python-libraries/</link>
    </image>
    
    <item>
      <title>Save the Pandas...library</title>
      <link>/post/pandas/useful/</link>
      <pubDate>Sat, 11 Jul 2020 00:00:00 +0000</pubDate>
      <guid>/post/pandas/useful/</guid>
      <description>


&lt;style&gt;

.bod{
  font-family: Arial;
  font-size: 11pt;
  display: inline-block;
  margin-left: 10px;
}

h2{
  text-decoration: underline;
  line-height: 5pt;
  text-align: center;
  padding-top: 30px;
}
h3{ 
  display: list-item;
  list-style-type: disc;
  list-style-position: inside;
  font-size:17px;
  font-family:&#34;Cambria&#34;;
}
&lt;/style&gt;
&lt;p&gt;By convention, “&lt;strong&gt;&lt;em&gt;df&lt;/em&gt;&lt;/strong&gt;” will refer to a dataframe object, while “&lt;strong&gt;&lt;em&gt;Series&lt;/em&gt;&lt;/strong&gt;” will refer to a series object.&lt;/p&gt;
&lt;hr /&gt;
&lt;div id=&#34;importing&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Importing&lt;/h2&gt;
&lt;div id=&#34;importing-the-libraries&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Importing the Libraries&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;import pandas as pd
import numpy as np        #NumPy library required by Pandas library&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;read-csv-file-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Read csv file data&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;df = pd.read_csv(file_path, index_col=None)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;about-dataset&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;About dataset&lt;/h2&gt;
&lt;div id=&#34;check-column-names&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Check column names&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;df.columns

Series.name&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;check-shape-of-object&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Check shape of object&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;df.shape

Series.shape&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;columns-of-a-specific-data-type-type&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Columns of a specific data type type&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;df.dtypes == &amp;#39;object&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;describe-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Describe data&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;df.describe()&lt;/code&gt;&lt;/pre&gt;
&lt;!-- ### --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ``` --&gt;
&lt;!-- &lt;br&gt; --&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;handling-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Handling data&lt;/h2&gt;
&lt;div id=&#34;apply-a-function-on-a-pandas-object&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Apply (a function on a pandas object)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;df.apply(FUN, axis=0, *args)    #FUN: any (valid) function to apply
                                #axis: axis to assess
                                #*args: additional keyword arguments for FUN&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;assign-new-columns&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Assign (new columns)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;df.assign(col_name = col_1*col_2/col_3)&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&#34;bod&#34;&gt;
Used to create new columns. Similar to “mutate” in R.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;filter&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Filter&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;df.filter(items=, like=None)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;get-dummies-aka-one-hot-encoding&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Get Dummies (aka One Hot Encoding)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;df.get_dummies(dummy_na=False, columns=None, sparse=False, drop_first=False, dtype=np.uint8)
        #dummy_na: if True, adds dummy column for NA
        #columns: if !None, columns specified will be one hot encoded
        #sparse: whether resulting columns will be SparseArray objects (True) or NumPy arrays(False) 
        #drop_first: removes first unique dummy variable from unique objects in column
        #dtype: data type for new columns (e.g. float)


Series.get_dummies(dummy_na=False, columns=None, sparse=False, drop_first=False, dtype=&amp;#39;np.uint8&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;handling-na&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Handling NA&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#Finding NA and inverse
df.isna()
Series.isna()

df.notna()
Series.isna()


#Dropping NA
df.dropna(axis=0, how=&amp;#39;any&amp;#39;, thresh=None, subset=None, inplace=False)
        #axis: axis to assess
        #how: when to drop axis (e.g. how=&amp;#39;all&amp;#39; drops IFF all values are NA)
        #thresh: number of NAs in axis to drop
        #subset: labels on axis to be considered
        #inplace: by default, returns new object. If True, modifies existing object
        
Series.dropna(axis=0, how=None,inplace=False)


#Filling NA
df.fillna(value=None, method=None, axis=None, inplace=False, limit=None)
        #value: value to fill holes
        #method: method for filling holes.*
        #inplace: by default, returns new object. If True, modifies existing object
        #limit: max number of consecutive NAs to fill. Will be left as NA if value is exceeded

Series.fillna(value=None, method=None, axis=None, inplace=False, limit=None)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;piping-data-through-multiple-functions&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Piping data (through multiple functions)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;(df.pipe(FUN1)
    .pipe(FUN2, arg1=foo)                  
    .pipe((FUN3, &amp;quot;arg2&amp;quot;), arg1=bar)        #when FUN3&amp;#39;s main arg. is not df, supply tuple
                                                where str contains location for df (e.g. &amp;quot;arg2&amp;quot;)
)&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&#34;bod&#34;&gt;
&lt;b&gt;NOTE&lt;/b&gt;: similar to %&amp;gt;% operation in R.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;query-columns&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Query (columns)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;df.query(&amp;#39;expression&amp;#39;)    #expression must be conditional using column variable/s
                          #prefix &amp;quot;@&amp;quot; before variable name if outside of dataframe env.
                          #prefix ` ` to encapsulate variable name with spaces&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&#34;bod&#34;&gt;
Can be used to filter rows.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;unique-vs-nunique&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Unique vs Nunique&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;for col in df.columns:    #for loop to get column names
  df[col].unique()            #returns unique values in column &amp;#39;col&amp;#39;
  df[col].nunique()           #returns unique values in column AND drop NAs&lt;/code&gt;&lt;/pre&gt;
&lt;!-- ### --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ``` --&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
